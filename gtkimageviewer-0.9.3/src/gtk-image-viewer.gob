/*
 * Copyright (C) 2008 Dov Grobgeld <dov.grobgeld@gmail.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */
requires 2.0.0

%headertop{
/*
 * Copyright (C) 2008 Dov Grobgeld <dov.grobgeld@gmail.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */
#include <stdlib.h>
#include <gtk/gtk.h>
#include <gtk/gtkadjustment.h>
%}

%{
/*
 * Copyright (C) 2008 Dov Grobgeld <dov.grobgeld@gmail.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */
#define DBG(a) 
#define DBG2(a)

static gint view_changed(GtkImageViewer *image_widget,
			 int do_force,
			 double scale_x,
			 double scale_y,
			 double x0,
			 double y0);

static gint zoom_reset(GtkImageViewer *self);
static gint zoom_translate(GtkImageViewer *self, int dx, int dy);
static gboolean update_adjustments(GtkImageViewer *image_viewer);
static void vadjustment_value_changed (GtkAdjustment *vadjustment,
                                       gpointer       data);
static void hadjustment_value_changed (GtkAdjustment *hadjustment,
                                       gpointer       data);

%}


class Gtk:Image:Viewer from Gtk:Widget
{
  private GdkPixbuf *image=NULL;
  private gdouble current_scale_x=1;
  private gdouble current_scale_y=1;
  private gint current_x0;
  private gint current_y0;
  private gint canvas_width;
  private gint canvas_height;
  private gboolean do_flip_vertical = FALSE;
  private gboolean do_flip_horizontal = FALSE;
  private gboolean do_use_transfer_map = FALSE;
  private gboolean do_fill_on_resize = TRUE;
  /* The one shot block is used by shrink wrapping to inhibit rescaling
     on resize. Is there a better way? */
  private gboolean one_shot_block_fill_on_resize = FALSE;
  private GdkInterpType interp_type = GDK_INTERP_NEAREST;
  private guint8 *transfer_map[3];
  private gboolean do_linear_zoom_steps;
  private gdouble min_zoom;
  private gdouble max_zoom;
  private GdkGC *gc;
  private gdouble scroll_min_x;
  private gdouble scroll_max_x;
  private gdouble scroll_min_y;
  private gdouble scroll_max_y;
  private gdouble scroll_width = -1;
  private gdouble scroll_height = -1;
  private GtkAdjustment *hadjustment = NULL;
  private GtkAdjustment *vadjustment = NULL;
  private gint last_x;
  private gint last_y;
  private gboolean is_mouse_button2_pressed = FALSE;
  private gdouble last_pan_anchor_x;
  private gdouble last_pan_anchor_y;
  private gint button;
  private GdkDrawable *cache_area = NULL;
  private gdouble cache_scale_x = -1;
  private gdouble cache_scale_y = -1;
  private gdouble cache_current_x0 = -1;
  private gdouble cache_current_y0 = -1;
  private gdouble cache_width = -1;
  private gdouble cache_height = -1;
  private gboolean frozen = FALSE;
  
  init(self)
  {
    GTK_WIDGET_SET_FLAGS (self, GTK_CAN_FOCUS);
    selfp->interp_type = GDK_INTERP_NEAREST;
    selfp->do_linear_zoom_steps = FALSE;
    selfp->do_use_transfer_map = FALSE;
    selfp->do_flip_vertical = FALSE;
    selfp->do_flip_horizontal = FALSE;
    selfp->current_scale_x = 1.0;
    selfp->current_scale_y = 1.0;
    selfp->current_x0 = 0;
    selfp->current_y0 = 0;
    selfp->min_zoom = 1.0/8;
    selfp->max_zoom = 128;
    selfp->scroll_width = -1;
    selfp->scroll_height = -1;
    selfp->gc = NULL;
    selfp->hadjustment = 0;
    selfp->vadjustment = 0;
    selfp->frozen = FALSE;
  }

  class_init(self) {
    // The following statement does the magic of connecting the scrolled_window
    // packing to the scrolling of the image viewer.
    ((GtkWidgetClass*)self)->set_scroll_adjustments_signal = object_signals[SET_SCROLL_ADJUSTMENTS_SIGNAL];
  }
  
  public GtkWidget *
  new (GdkPixbuf *pixbuf)
  {
    GtkImageViewer *self = GTK_IMAGE_VIEWER(GET_NEW);

    gtk_image_viewer_set_image(self, pixbuf);
    
    return GTK_WIDGET(self);
  }

  public GtkWidget *
  new_from_file (const gchar *filename)
  {
    GError *error = NULL;
    GdkPixbuf *pb = gdk_pixbuf_new_from_file(filename, &error);

    return gtk_image_viewer_new(pb);
  }

  override (Gtk:Widget)
  void
  realize (Gtk:Widget *self (check null type))
  {
    GtkWidget *widget = GTK_WIDGET(self);
    GdkWindowAttr attributes;
    gint attributes_mask;
    
    GTK_WIDGET_SET_FLAGS (widget, GTK_REALIZED);
      
    attributes.x = widget->allocation.x;
    attributes.y = widget->allocation.y;
    attributes.width = widget->allocation.width;
    attributes.height = widget->allocation.height;
    attributes.wclass = GDK_INPUT_OUTPUT;
    attributes.window_type = GDK_WINDOW_CHILD;
    attributes.event_mask = gtk_widget_get_events (widget) | 
      GDK_EXPOSURE_MASK |
      GDK_BUTTON_PRESS_MASK | 
      GDK_BUTTON_RELEASE_MASK |
      GDK_POINTER_MOTION_MASK |
      GDK_POINTER_MOTION_HINT_MASK | 
      GDK_KEY_PRESS_MASK |
      GDK_LEAVE_NOTIFY_MASK |
      GDK_ENTER_NOTIFY_MASK;
    attributes.visual = gtk_widget_get_visual (widget);
    attributes.colormap = gtk_widget_get_colormap (widget);
      
    attributes_mask = GDK_WA_X | GDK_WA_Y | GDK_WA_VISUAL | GDK_WA_COLORMAP;
    widget->window = gdk_window_new (widget->parent->window, &attributes, attributes_mask);
      
    widget->style = gtk_style_attach (widget->style, widget->window);
      
    gdk_window_set_user_data (widget->window, widget);
      
    // Force background to be white. This is uggly and should be fixed!
    {
      GdkColor color;
      gdk_color_parse("white", &color);
      gtk_widget_modify_bg(self, GTK_STATE_NORMAL, &color);
      gtk_widget_modify_bg(self, GTK_STATE_ACTIVE, &color);
    }

    //    gtk_style_set_background (widget->style, widget->window, GTK_STATE_ACTIVE);
  }

  override (Gtk:Widget)
  void
  size_request (GtkWidget      *widget,
                GtkRequisition *requisition)
  {
    GtkImageViewer *self = GTK_IMAGE_VIEWER (widget);

    if (selfp->image) 
      {
        requisition->width = gdk_pixbuf_get_width(selfp->image);
        requisition->height = gdk_pixbuf_get_height(selfp->image);
      }
    else
      {
        requisition->width = 256;
        requisition->height = 256;
      }
  }
  
  override (Gtk:Widget)
  void 
  size_allocate (GtkWidget     *widget,
                 GtkAllocation *allocation)
  {
    GtkImageViewer *self;
    int old_cnv_w, old_cnv_h;
  
    widget->allocation = *allocation;
    self = GTK_IMAGE_VIEWER (widget);
  
    if (GTK_WIDGET_REALIZED (widget)) {
        gdk_window_move_resize (widget->window,
                                allocation->x, allocation->y,
                                allocation->width, allocation->height);
        
        
    }
    
    old_cnv_w = selfp->canvas_width;
    old_cnv_h = selfp->canvas_height;

    selfp->canvas_width = widget->allocation.width;
    selfp->canvas_height = widget->allocation.height;
    if (GTK_IS_SCROLLED_WINDOW(GTK_WIDGET(self)->parent)) {
      GtkPolicyType hscrollbar_policy, vscrollbar_policy;
      gtk_scrolled_window_get_policy(GTK_SCROLLED_WINDOW(GTK_WIDGET(self)->parent),
                                     &hscrollbar_policy,
                                     &vscrollbar_policy);
#if 0
        printf("Replacing with parent size (%d,%d)->(%d,%d)...\n",
               selfp->canvas_width,
               selfp->canvas_height,
               GTK_WIDGET(self)->parent->allocation.width,
               GTK_WIDGET(self)->parent->allocation.height
               );
#endif
        if (hscrollbar_policy != GTK_POLICY_ALWAYS)
          selfp->canvas_width = GTK_WIDGET(self)->parent->allocation.width;
        
        if (vscrollbar_policy != GTK_POLICY_ALWAYS)
          selfp->canvas_height = GTK_WIDGET(self)->parent->allocation.height;
    }

    // If we were called because the scrollbar automatically appeared
    // then the scrolled_window size hasn't changed, and we don't shouldn't
    // do anything.
    if (old_cnv_w == selfp->canvas_width
        && old_cnv_h == selfp->canvas_height)
        return;

    double scale_factor = 1.0;

    if (!selfp->one_shot_block_fill_on_resize
        && selfp->do_fill_on_resize) {
        double sw = selfp->scroll_width;
        double sh = selfp->scroll_height; 
        double cw = selfp->canvas_width;
        double ch = selfp->canvas_height;

        if (sw < 0)
            sw = cw;
        if (sh < 0)
            sh = ch;
        
        // This should be made more sophisticated.
#if 0
        if (!selfp->image) {
            cw-= 20;
            ch-= 20;
        }
#endif

        if (old_cnv_w == 0)
          scale_factor = 1;
        else
          scale_factor = 1.0*cw/old_cnv_w;
        if (scale_factor * selfp->current_scale_x * sw < cw)
            scale_factor = cw / sw / selfp->current_scale_x;

        double scale_factor_y = 1;
        if (old_cnv_h > 0)
           scale_factor_y = 1.0*ch/old_cnv_h;
        if (scale_factor_y * selfp->current_scale_y * sh < ch)
            scale_factor_y = ch/sh/selfp->current_scale_y;
        if (scale_factor_y < scale_factor)
            scale_factor = scale_factor_y;
    }
    selfp->one_shot_block_fill_on_resize = FALSE;

    selfp->current_scale_x *= scale_factor;
    selfp->current_scale_y *= scale_factor;
    selfp->current_x0 *= scale_factor;
    selfp->current_y0 *= scale_factor;
  
    /* Update current_x0 and current_y0 to center data if the
     * new size is wider than scale * image size.
     */
    {
        double scale_x = selfp->current_scale_x;
        double scale_y = selfp->current_scale_y;
        double img_w = selfp->scroll_width*scale_x;
        double img_h = selfp->scroll_height*scale_y;
        int cnv_w = selfp->canvas_width;
        int cnv_h = selfp->canvas_height;
  
        DBG(fprintf(stderr,"Resize: x0 y0 img_w img_h cnv_w cnv_h = %d %d %f %f %d %d\n",
                    selfp->current_x0,selfp->current_y0,img_w,img_h,cnv_w,cnv_h));
  
        if (cnv_w > img_w)
          selfp->current_x0 = -(cnv_w-img_w)/2+selfp->scroll_min_x*scale_x;
        else if (old_cnv_w > img_w)
          selfp->current_x0 = selfp->scroll_min_x*scale_x;
        else if (img_w - selfp->current_x0 < cnv_w)
          {
            DBG(fprintf(stderr, "Resize case 3X\n"));
            selfp->current_x0 = img_w-cnv_w+selfp->scroll_min_x*scale_x;
          }
        if (cnv_h > img_h)
          selfp->current_y0 = -(cnv_h-img_h)/2+selfp->scroll_min_y*scale_y;
        else if (old_cnv_h > img_h)
          selfp->current_y0 = selfp->scroll_min_y*scale_y;
        else if (img_h - selfp->current_y0 < cnv_h)
          {
            DBG(fprintf(stderr, "Resize case 3Y\n"));
            selfp->current_y0 = img_h-cnv_h+selfp->scroll_min_y*scale_y;
          }
      }
  }

  override (Gtk:Widget)
  gint
  expose_event (GtkWidget      *widget,
                GdkEventExpose *event)
  {
    //    printf("expose_event\n");
    gtk_image_viewer_expose_area(GTK_IMAGE_VIEWER(widget),
                                 event->area.x, event->area.y,
                                 event->area.width, event->area.height);
    
    return FALSE;
  }

  override (Gtk:Widget)
  gint
  enter_notify_event(GtkWidget *widget,
                     GdkEventCrossing *event)
  {
    // printf("Enter notify\n");
    if (!GTK_WIDGET_HAS_FOCUS (widget))
      gtk_widget_grab_focus (widget);
    
    return TRUE;
  }

  override (Gtk:Widget)
  gint
  leave_notify_event(GtkWidget *widget,
                     GdkEventCrossing *event)
  {
    // printf("Leave notify\n");
    if (!GTK_WIDGET_HAS_FOCUS (widget))
      gtk_widget_grab_focus (widget);
    
    return TRUE;
  }

  override (Gtk:Widget)
  gint
  key_press_event (GtkWidget   *widget,
                   GdkEventKey *event)
  {
    GtkImageViewer *self = GTK_IMAGE_VIEWER(widget);
    int ret = TRUE;
    gint k;

    k = event->keyval;

    switch (k) {
    case '=':
    case '+':
        gtk_image_viewer_zoom_in(self, -1, -1, 1.1);
        break;
    case '>':
        gtk_image_viewer_zoom_in(self, -1, -1, 2);
        break;
    case '<':
        gtk_image_viewer_zoom_out(self, 0, 0, 2);
        break;
    case '-':
        gtk_image_viewer_zoom_out(self, 0, 0, 1.1);
        break;
    case '1':
    case 'n':
        zoom_reset(self);
        break;
    case 'f':
        gtk_image_viewer_zoom_fit(self);
        break;
    case 'v':
        gtk_image_viewer_set_flip(self,
                                  selfp->do_flip_horizontal,
                                  !selfp->do_flip_vertical);
        break;
    case 'h':
        gtk_image_viewer_set_flip(self,
                                  !selfp->do_flip_horizontal,
                                  selfp->do_flip_vertical);
        break;
    default:
        ret = FALSE;
        break;
    }
    return ret;
  }

  override (Gtk:Widget)
  gint
  button_press_event (GtkWidget *widget,
                      GdkEventButton *event)
  {
    GtkImageViewer *self = GTK_IMAGE_VIEWER(widget);
    int button = event->button;
    double x = event->x;
    double y = event->y;
  
    if (button == 1)
        gtk_image_viewer_zoom_in(self, (int)x, (int)y, 2);
    else if (button == 2)
      {
        gtk_grab_add (GTK_WIDGET(self));
        selfp->is_mouse_button2_pressed = TRUE;
        selfp->last_pan_anchor_x = x;
        selfp->last_pan_anchor_y = y;
      }
    else if (button == 3)
        gtk_image_viewer_zoom_out(self, (int)x, (int)y, 2);
    
    selfp->button = event->button;
    
    return FALSE;
  }

  override (Gtk:Widget)
  gint
  button_release_event (GtkWidget      *widget,
                        GdkEventButton *event)
  {
    GtkImageViewer *self;
    gdouble x = event->x;
    gdouble y = event->y;
  
    g_return_val_if_fail (widget != NULL, FALSE);
    g_return_val_if_fail (GTK_IS_IMAGE_VIEWER (widget), FALSE);
    g_return_val_if_fail (event != NULL, FALSE);
  
    self = GTK_IMAGE_VIEWER (widget);
  
    if (selfp->button == (int)event->button)
      {
        if (selfp->is_mouse_button2_pressed) {
  	selfp->is_mouse_button2_pressed = FALSE;
  	if (selfp->last_pan_anchor_x>0 && selfp->last_pan_anchor_y > 0)
  	    zoom_translate(self,
                           (int)(selfp->last_pan_anchor_x-x),
  			   (int)(selfp->last_pan_anchor_y-y));
  	gtk_grab_remove (GTK_WIDGET(self));
  
  	/* Emit an additional view changed signal at the end of the scrolling
  	   in order to support redrawing only when the panning is done.
  	*/
#if 0
  	gtk_signal_emit(GTK_OBJECT(image_viewer), gtk_image_viewer_signals[VIEW_CHANGED]);
#endif

        }
      }
  
    return FALSE;
  }

  
  /*======================================================================
  //  The motion callback should scroll the image. The current solution
  //  unfortunately does not create smooth scrolling. A further
  //  investigation of how e.g. gimp does it is needed.
  //----------------------------------------------------------------------
  */
  override (Gtk:Widget)
  gint
  motion_notify_event (GtkWidget      *widget,
                       GdkEventMotion *event)
  {
    GtkImageViewer *self;
    GdkModifierType state;
    gint x, y;
  
    g_return_val_if_fail (widget != NULL, FALSE);
    g_return_val_if_fail (GTK_IS_IMAGE_VIEWER (widget), FALSE);
    g_return_val_if_fail (event != NULL, FALSE);
  
    self = GTK_IMAGE_VIEWER (widget);
  
    if (event->is_hint) {
       gdk_window_get_pointer(event->window, &x, &y, &state);
    } else {
       x = (int) event->x;
       y = (int) event->y;
    }
    selfp->last_x = x;
    selfp->last_y = y;
  
    if (selfp->is_mouse_button2_pressed)
      {
        if (selfp->last_pan_anchor_x>0 && selfp->last_pan_anchor_y > 0)
          {
            int dx = (int)(selfp->last_pan_anchor_x-x);
            int dy = (int)(selfp->last_pan_anchor_y-y);

            if (selfp->do_flip_horizontal)
              dx = -dx;
            if (selfp->do_flip_vertical)
              dy = -dy;
            zoom_translate(self, dx, dy);
          }
        
        selfp->last_pan_anchor_x = x;
        selfp->last_pan_anchor_y = y;
  
        return TRUE;
      }
    
    return FALSE;
  }

  override (Gtk:Widget)
  gint
  scroll_event (GtkWidget      *widget,
                GdkEventScroll *event)
  {
    GtkImageViewer *self = GTK_IMAGE_VIEWER(widget);
    /* Add the following in order only to get control scroll.
    if (event->state & GDK_CONTROL_MASK)
     */
    {
      gdouble x = event->x;
      gdouble y = event->y;
      if (event->direction)
          //zoom_in(self, (int)x,(int)y);
          gtk_image_viewer_zoom_out(self, (int)x,(int)y,1.1);
      else
          gtk_image_viewer_zoom_in(self, -1,-1,1.1);
      return 1;
    }
    return 0;
  }


  /** 
   * 
   * @param exp_x0 
   * @param exp_y0 
   * @param w 
   * @param h 
   */
  public
  void
  expose_area(self,
              int exp_x0, int exp_y0,
              int w, int h)
  {
    GtkWidget *widget = GTK_WIDGET(self); /* In order to access window */
    GdkPixbuf *img_scaled = NULL;
    double scale_x = selfp->current_scale_x;
    double scale_y = selfp->current_scale_y;
    int exp_x1 = exp_x0 + w;
    int exp_y1 = exp_y0 + h;
    int offs_x = -selfp->current_x0-exp_x0;
    int offs_y = -selfp->current_y0-exp_y0;
    int trans_offs_x = offs_x;
    int trans_offs_y = offs_y;
    int dst_x = exp_x0;
    int dst_y = exp_y0;
    int copy_w = w;
    int copy_h = h;
    int cnv_w = selfp->canvas_width;
    int cnv_h = selfp->canvas_height;

    // This doesn't work yet. If the adjustments changed then there
    // is no reason to expose.
    if (update_adjustments(self))
      return;

#if 0
    printf("Expose area %d %d %d %d\n",
           exp_x0, exp_y0, w, h);
#endif

    // Check if we have a cached version of the exposed area and
    // that the settings of the cache match the current settings.
    if (selfp->cache_area) {
        if (selfp->cache_scale_x == scale_x
            && selfp->cache_scale_y == scale_y
            && selfp->cache_current_x0 == selfp->current_x0
            && selfp->cache_current_y0 == selfp->current_y0
            && selfp->cache_width == selfp->canvas_width
            && selfp->cache_height == selfp->canvas_height
            ) {

#if 0
            printf("Restoring cache!\n");
#endif
            /* Scroll visible region */
            gdk_draw_drawable (widget->window,
                               selfp->gc,
                               selfp->cache_area,
                               exp_x0, exp_y0,
                               exp_x0, exp_y0,
                               w,h);
            return;
        }
        else {
            // invalidate cache
            gdk_drawable_unref(selfp->cache_area);
            selfp->cache_area = NULL;
        }
    }

    if (selfp->image)
      {
  				/* Canvas size */
        int img_w, img_h;		/* Image's size (pixels) */
        int img_x0 = 0;
        int img_x1 = cnv_w;
        int img_y0 = 0;
        int img_y1 = cnv_h;
        img_w = gdk_pixbuf_get_width(selfp->image);
        img_h = gdk_pixbuf_get_height(selfp->image);
        DBG(fprintf(stderr, "current_x0 exp_x0 offs_x = %d %d %d\n",
                    selfp->current_x0,
                    exp_x0,
                    offs_x));
  
        /* If img fits in canvas horizontally, need a smaller drawing zone */
        if (img_w * scale_x < cnv_w) 
          {
            img_x0 = (int)((cnv_w - img_w*scale_x)/2);
            img_x1 = (int)(img_x0 + img_w*scale_x);
          }
        
        /* If img fits in canvas vertically : need a smaller drawing zone */
        if (img_h * scale_y < cnv_h)
          {
            img_y0 = (int)((cnv_h - img_h*scale_y)/2);
            img_y1 = (int)(img_y0 + img_h*scale_y);
          }
        
        if (exp_x1 < img_x0)
          {
            DBG(fprintf(stderr, "Case 1X\n"));
            copy_w = 0;
            offs_x = 0;
            dst_x = img_x0;
            gdk_draw_rectangle(widget->window,
                               widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
                               TRUE,
                               exp_x0,exp_y0,w, h);
          }
        else if (exp_x0 < img_x0 && exp_x1 > img_x1)
          {
            DBG(fprintf(stderr, "Case 2X\n"));
            copy_w = w - (img_x0 - exp_x0) - (exp_x1 - img_x1);
            dst_x = img_x0;

            if (selfp->do_flip_horizontal)
              {
                trans_offs_x = selfp->current_x0+exp_x0+cnv_w-img_x0;
                offs_x = 0;
              }
            else
              trans_offs_x = offs_x = 0;
            
            gdk_draw_rectangle(widget->window,
                               widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
                               TRUE,
                               exp_x0,exp_y0,(img_x0-exp_x0), h);
            gdk_draw_rectangle(widget->window,
                               widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
                               TRUE,
                               img_x1,exp_y0,(exp_x1-img_x1), h);
          }
        else if (exp_x0 < img_x0)
          {
            DBG(fprintf(stderr, "Case 3X\n"));
            copy_w = w - (img_x0 - exp_x0);
            dst_x = img_x0;

            if (selfp->do_flip_horizontal)
              {
                offs_x = (int)(-(img_w*scale_x-(exp_x1-img_x0)));
                trans_offs_x = selfp->current_x0+cnv_w-img_x0;
              }
            else
              offs_x = trans_offs_x = 0;
            
            gdk_draw_rectangle(widget->window,
                               widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
                               TRUE,
                               exp_x0,exp_y0,(img_x0-exp_x0), h);
          }
        else if (exp_x0 > img_x1)
          {
            DBG(fprintf(stderr, "Case 4X\n"));
            copy_w = 0;
            gdk_draw_rectangle(widget->window,
                               widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
                               TRUE,
                               exp_x0,exp_y0,w, h);
            
          }
        else if (exp_x1 > img_x1)
          {
            DBG(fprintf(stderr, "Case 5X\n"));
            copy_w = w - (exp_x1 - img_x1);
            dst_x = exp_x0;

            if (selfp->do_flip_horizontal)
              {
                trans_offs_x = selfp->current_x0-exp_x0+cnv_w;
                offs_x = 0;
              }
            else
              offs_x = trans_offs_x = -(exp_x0-img_x0);
            
            gdk_draw_rectangle(widget->window,
                               widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
                               TRUE,
                               img_x1,exp_y0,exp_x1-img_x1, h);
          }
        else
          {
            DBG(fprintf(stderr, "Case 6X\n"));
            dst_x = exp_x0;
            copy_w = w;
            
            if (selfp->do_flip_horizontal)
              {
                offs_x = -(cnv_w + selfp->current_x0 - exp_x1);
                trans_offs_x = selfp->current_x0-exp_x0+cnv_w;
              }
            else
              offs_x = trans_offs_x = -selfp->current_x0-exp_x0;
          }
  
        /* Y dir */
        if (exp_y1 < img_y0)
          {
            DBG(fprintf(stderr, "Case 1Y\n"));
            copy_h = 0;
            offs_y = 0;
            dst_x = img_y0;
            gdk_draw_rectangle(widget->window,
  			     widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
                               TRUE,
                               exp_x0,exp_y0,w, h);
          }
        else if (exp_y0 < img_y0 && exp_y1 > img_y1)
          {
            DBG(fprintf(stderr, "Case 2Y\n"));
            copy_h = h - (img_y0 - exp_y0) - (exp_y1 - img_y1);
            dst_y = img_y0;
            
            if (selfp->do_flip_vertical)
              {
                trans_offs_y = selfp->current_y0+exp_y0+cnv_h-img_y0;
                offs_y = 0;
              }
            else
              trans_offs_y = offs_y = 0;
            
            gdk_draw_rectangle(widget->window,
                               widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
                               TRUE,
                               exp_x0,exp_y0,w, img_y0-exp_y0);
            gdk_draw_rectangle(widget->window,
                               widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
                               TRUE,
                               exp_x0, img_y1,w, exp_y1-img_y1);
          }
        else if (exp_y0 < img_y0)
          {
            DBG(fprintf(stderr, "Case 3Y\n"));
            copy_h = h - (img_y0 - exp_y0);
            dst_y = img_y0;
            
            if (selfp->do_flip_vertical)
              {
                offs_y = (int)(-(img_h*scale_y-(exp_y1-img_y0)));
                trans_offs_y = selfp->current_y0+cnv_h-img_y0;
              }
            else
              offs_y = trans_offs_y = 0;

            gdk_draw_rectangle(widget->window,
                               widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
                               TRUE,
                               exp_x0,exp_y0,w,(img_y0-exp_y0));
          }
        else if (exp_y0 > img_y1)
          {
            DBG(fprintf(stderr, "Case 4Y\n"));
            copy_h = 0;
            gdk_draw_rectangle(widget->window,
                               widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
                               TRUE,
                               exp_x0,exp_y0,w, h);
            
          }
        else if (exp_y1 > img_y1)
          {
            DBG(fprintf(stderr, "Case 5Y\n"));
            copy_h = h - (exp_y1 - img_y1);
            dst_y = exp_y0;

            if (selfp->do_flip_vertical)
              {
                trans_offs_y = selfp->current_y0-exp_y0+cnv_h;
                offs_y = 0;
              }
            else
              offs_y = trans_offs_y = -(exp_y0-img_y0);
            
            gdk_draw_rectangle(widget->window,
                               widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
                               TRUE,
                               exp_x0,img_y1,w,exp_y1-img_y1);
          }
        else
          {
            DBG(fprintf(stderr, "Case 6Y\n"));
            dst_y = exp_y0;
            copy_h = h;

            if (selfp->do_flip_vertical)
              {
                offs_y = -(cnv_h + selfp->current_y0 - exp_y1);
                trans_offs_y = selfp->current_y0-exp_y0+cnv_h;
              }
            else
              offs_y = trans_offs_y = -selfp->current_y0-exp_y0;
          }
        
  
        DBG(fprintf(stderr, "dst_x dst_y copy_w copy_h offs_x offs_y = %d %d %d %d %d %d\n",
  	      dst_x, dst_y, copy_w, copy_h,
  	      selfp->current_x0, selfp->current_y0));
        /* Scale and copy the image */
        if (copy_w > 0 && copy_h > 0)
          {
            img_scaled = gdk_pixbuf_new(gdk_pixbuf_get_colorspace(selfp->image),
                                        TRUE,
                                        gdk_pixbuf_get_bits_per_sample(selfp->image),
                                        copy_w, copy_h);

#if 0
            if (selfp->do_flip_horizontal*0)
              {
                DBG(printf("old: offs_x w*scale_x exp_x0 current_x0 cnv_w=%d %f %d %d %d\n",
                           offs_x, w*scale_x, exp_x0, selfp->current_x0, cnv_w));

#if 0
                offs_x = -selfp->current_x0-(cnv_w-exp_x1);
                if (w * scale_x < cnv_w)
                  offs_x -= (cnv_w - w*scale_x)/2;
#endif
                offs_x = cnv_w+offs_x - (exp_x1-exp_x0);
                DBG(printf("b4 adj offs_x cnv_w img_w*scale_x cnv_w-img_w*scale_x= %d %d %.1f %.1f\n", offs_x, cnv_w, img_w*scale_x, cnv_w - img_w*scale_x));
                if (img_w * scale_x < cnv_w)
                  offs_x -= (cnv_w - img_w*scale_x)/2;
                    
                DBG(printf("new_offs_x=%d\n", offs_x));
              }
            if (selfp->do_flip_vertical)
              offs_y = -selfp->current_x0-(cnv_h-exp_x1);
#endif
            
            /* Check legality */
            DBG(fprintf(stderr, "offs_x copy_x scale_x w = %d %d %f %d\n",
                        offs_x, copy_w, scale_x, img_w));
            gdk_pixbuf_scale(selfp->image,
                             img_scaled,
                             0,0,
                             copy_w,
                             copy_h,
                             offs_x,
                             offs_y,
                             scale_x, scale_y,
                             selfp->interp_type);
            
            if (selfp->do_use_transfer_map)
              {
                /* Assume we are doing 8-bit... */
                guint8 *buf_scaled = gdk_pixbuf_get_pixels(img_scaled);
                gint w = gdk_pixbuf_get_width(img_scaled);
                gint h = gdk_pixbuf_get_height(img_scaled);
                gint rs = gdk_pixbuf_get_rowstride(img_scaled);
                gint row_idx, col_idx;
                guint8 *rmap = selfp->transfer_map[0];
                guint8 *gmap = selfp->transfer_map[1];
                guint8 *bmap = selfp->transfer_map[2];
                
                for (row_idx=0; row_idx<h; row_idx++)
                  {
                    guint8 *p = &buf_scaled[rs*row_idx];
                    
                    for (col_idx=0; col_idx<w; col_idx++)
                      {
                        *p = rmap[*p]; p++;
                        *p = gmap[*p]; p++;
                        *p = bmap[*p]; p++;
                      }
                  }
              }
            
            if (selfp->do_flip_vertical)
              {
                /* Assume we are doing 8-bit... */
                guint8 *buf_scaled = gdk_pixbuf_get_pixels(img_scaled);
                gint w = gdk_pixbuf_get_width(img_scaled);
                gint h = gdk_pixbuf_get_height(img_scaled);
                gint rs = gdk_pixbuf_get_rowstride(img_scaled);
                gint row_idx, col_idx;
                
                for (row_idx=0; row_idx<h/2; row_idx++)
                  {
                    guint8 *ptr1 = buf_scaled+rs * row_idx;
                    guint8 *ptr2 = buf_scaled+rs * (h-row_idx-1);
                    
                    for (col_idx=0; col_idx<w; col_idx++)
                      {
                        guint8 tmp_r = *ptr1;
                        guint8 tmp_g = *(ptr1+1);
                        guint8 tmp_b = *(ptr1+2);
                        guint8 tmp_alpha = *(ptr1+3);
                        *ptr1++ = *ptr2;
                        *ptr1++ = *(ptr2+1);
                        *ptr1++ = *(ptr2+2);
                        *ptr1++ = *(ptr2+3);
                        *ptr2++ = tmp_r;
                        *ptr2++ = tmp_g;
                        *ptr2++ = tmp_b;
                        *ptr2++ = tmp_alpha;
                      }
                  }
              }
            
            if (selfp->do_flip_horizontal)
              {
  	      /* Assume we are doing 8-bit... */
  	      guint8 *buf_scaled = gdk_pixbuf_get_pixels(img_scaled);
  	      gint w = gdk_pixbuf_get_width(img_scaled);
  	      gint h = gdk_pixbuf_get_height(img_scaled);
  	      gint rs = gdk_pixbuf_get_rowstride(img_scaled);
  	      gint row_idx, col_idx, clr_idx;
  	      
                for (col_idx = 0; col_idx < w/2; col_idx++)
                  {
                    for (row_idx = 0; row_idx <h; row_idx++)
                      {
                        int l_idx = row_idx * rs + col_idx*4;
                        int r_idx = row_idx * rs + (w - col_idx - 1)*4;
                        
                        for (clr_idx=0; clr_idx<4; clr_idx++)
                          {
                            guint8 tmp = buf_scaled[l_idx+clr_idx];
                            buf_scaled[l_idx+clr_idx] = buf_scaled[r_idx+clr_idx];
                            buf_scaled[r_idx+clr_idx] = tmp;
                          }
                      }
                  }
              }


  	}
      }

    // If we are working without a background image then create one
    // now for the painting.
    if (!img_scaled)
      {
        img_scaled = gdk_pixbuf_new(GDK_COLORSPACE_RGB,
                                    TRUE,
                                    8,
                                    w, h);
        if (selfp->do_flip_horizontal)
          offs_x = selfp->current_x0+w-exp_x1+cnv_w;
        else
          offs_x = -selfp->current_x0-exp_x0;
        DBG(printf("No image: current_x0=%d offs_x = %d\n", selfp->current_x0, offs_x));
        if (selfp->do_flip_vertical)
          offs_y = selfp->current_y0+h-exp_y1+cnv_h;
        else
          offs_y = -selfp->current_y0-exp_y0;
        dst_x = exp_x0;
        dst_y = exp_y0;
        copy_w = w;
        copy_h = h;

        gdk_pixbuf_fill(img_scaled,
                        0xffffffff);
    }
    else
      {
        offs_x = trans_offs_x;
        offs_y = trans_offs_y;
      }
          
    // Image annotation signal
#if 0
    printf("preparing for emit. frozen = %d\n",
           selfp->frozen);
#endif
    if (!selfp->frozen) {
        GValue ___param_values[6];
        GValue ___return_val;
        int i;

        int signal_shift_x = offs_x;
        int signal_shift_y = offs_y;
        double signal_scale_x = scale_x;
        double signal_scale_y = scale_y;

        // Flip the scale and shift if we are flipped
        if (selfp->do_flip_horizontal)
          signal_scale_x = -signal_scale_x;
        if (selfp->do_flip_vertical)
          signal_scale_y = -signal_scale_y;
              
        memset (&___return_val, 0, sizeof (___return_val));
        memset (&___param_values, 0, sizeof (___param_values));
        
        ___param_values[0].g_type = 0;
        g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
        g_value_set_instance (&___param_values[0], (gpointer) self);
        
        ___param_values[1].g_type = 0;
        g_value_init (&___param_values[1], G_TYPE_POINTER);
        g_value_set_pointer (&___param_values[1], img_scaled);
        
        ___param_values[2].g_type = 0;
        g_value_init (&___param_values[2], G_TYPE_INT);
        g_value_set_int (&___param_values[2], -signal_shift_x);
        
        ___param_values[3].g_type = 0;
        g_value_init (&___param_values[3], G_TYPE_INT);
        g_value_set_int (&___param_values[3], -signal_shift_y);
        
        ___param_values[4].g_type = 0;
        g_value_init (&___param_values[4], G_TYPE_DOUBLE);
        g_value_set_double (&___param_values[4], signal_scale_x);
        
        ___param_values[5].g_type = 0;
        g_value_init (&___param_values[5], G_TYPE_DOUBLE);
        g_value_set_double (&___param_values[5], signal_scale_y);
        
        //        printf("Emitting!\n");
        g_signal_emitv (___param_values,
                        object_signals[IMAGE_ANNOTATE_SIGNAL],
                        0 /* detail */,
                        &___return_val);
        
        //printf("Done emitting!\n");
        for (i=0; i<6; i++)
            g_value_unset (&___param_values[i]);
    }

    // Add checkerboard below images that have alpha channel
    if (gdk_pixbuf_get_has_alpha(img_scaled)) {
        GdkPixbuf *img_comp = gdk_pixbuf_new(gdk_pixbuf_get_colorspace(img_scaled),
                                             TRUE,
                                             gdk_pixbuf_get_bits_per_sample(img_scaled),
                                             copy_w, copy_h);
        gdk_pixbuf_composite_color(img_scaled,
                                   img_comp,
                                   0,0,
                                   copy_w, copy_h,
                                   0,0,
                                   1.0,1.0,
                                   GDK_INTERP_NEAREST,
                                   255,
                                   -(int)offs_x,
                                   -(int)offs_y,
                                   16,
                                   0xff505050,
                                   0xffa0a0a0
                                   );
        gdk_pixbuf_unref(img_scaled);
        img_scaled = img_comp;
    }
    if (!selfp->frozen)
      gdk_draw_pixbuf (widget->window,
                       widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
                       img_scaled,
                       0, 0,
                       dst_x, dst_y,
                       copy_w, copy_h,
                       GDK_RGB_DITHER_NORMAL,
                       selfp->current_x0,
                       selfp->current_y0);
    
    gdk_pixbuf_unref(img_scaled);

    // If we have just drawn the whole buffer, then copy the result
    // to the cache.
    if (w == selfp->canvas_width
        && h == selfp->canvas_height) {
        selfp->cache_area = gdk_pixmap_new(widget->window,
                                           w,h,
                                           -1);
        if (!selfp->gc) {
            selfp->gc = gdk_gc_new(widget->window);
            gdk_gc_copy(selfp->gc, widget->style->white_gc);
            gdk_gc_set_exposures(selfp->gc, TRUE);
	}

        gdk_draw_drawable(selfp->cache_area,
                          selfp->gc,
                          widget->window,
                          0,0,
                          0,0,
                          -1, -1);
        selfp->cache_current_x0 = selfp->current_x0;
        selfp->cache_current_y0 = selfp->current_y0;
        selfp->cache_scale_x = selfp->current_scale_x;
        selfp->cache_scale_y = selfp->current_scale_y;
        selfp->cache_width = selfp->canvas_width;
        selfp->cache_height = selfp->canvas_height;
#if 0
        printf("Storing cache! (x0,y0,sx,sy) = (%d %d %f %f)\n",
               selfp->current_x0, selfp->current_y0,
               selfp->current_scale_x, selfp->current_scale_y);
#endif
    }
  
#if 0
    gtk_signal_emit(GTK_OBJECT(self), gtk_image_viewer_signals[VIEW_CHANGED]);
#endif
  }

  public void
  set_freeze(self,
             gboolean is_frozen)
  {
    selfp->frozen = is_frozen;
    if (!selfp->frozen)
      gtk_image_viewer_redraw(self,
                              TRUE);
  }

  public
  gint
  redraw(self,
         gboolean clear_cache)
  {
    if (clear_cache) {
      if (selfp->cache_area) 
        gdk_drawable_unref(selfp->cache_area);
      selfp->cache_area = NULL;
    }
    if (GTK_WIDGET(self)->window)
      gtk_image_viewer_expose_area(self,
                                   0,0,
                                   GTK_WIDGET(self)->allocation.width,
                                   GTK_WIDGET(self)->allocation.height);
    return FALSE;
  }

  /*======================================================================
  //  gtk_image_viewer_zoom_around_fixed_point is a preprocessor
  //  to view_changed that allows a zooming while moving an old pixel
  //  coordinate to a given new position. E.g. moving the x,y coordinate
  //  clicked by the mouse to the center of the zoomed up image.
  //----------------------------------------------------------------------
  */
  public
  gint
  zoom_around_fixed_point(self,
                          double new_scale_x,
                          double new_scale_y,
                          double old_x,
                          double old_y,
                          double new_x,
                          double new_y)
  {
      double w = selfp->canvas_width;
      double h = selfp->canvas_height;
      double old_scale_x, old_scale_y, old_x0, old_y0, new_x0, new_y0;
      DBG(printf("zoom_around_fixed_point: nsx nsy old_x old_y new_x new_y = %f %f  %f %f  %f %f\n",
                 new_scale_x, new_scale_y,
                 old_x, old_y,
                 new_x, new_y));
      
      g_return_val_if_fail (self != NULL, FALSE);
      g_return_val_if_fail (GTK_IS_IMAGE_VIEWER (self), FALSE);
      
      /* Short cuts */
      old_x0 = selfp->current_x0;
      old_y0 = selfp->current_y0;
      old_scale_x = selfp->current_scale_x;
      old_scale_y = selfp->current_scale_y;
      
      
      if (selfp->do_flip_horizontal) {
          old_x = w - old_x;
          new_x = w - new_x;
      }
      if (selfp->do_flip_vertical) {
          old_y = h - old_y;
          new_y = h - new_y;
      }
      
      new_x0 = new_scale_x/old_scale_x * (old_x + old_x0) - new_x;
      new_y0 = new_scale_y/old_scale_y * (old_y + old_y0) - new_y;
      
      DBG(printf("old_x0 new_x0 = %f %f\n", old_x0, new_x0));
      view_changed(self, FALSE, new_scale_x, new_scale_y, new_x0, new_y0);
      
      return 0;
  }

  public gint
  zoom_in(self, int x, int y, double factor)
  {
    double zoom_factor[2];
    int zoom_idx;
    if (factor < 0)
      factor = 1.1;
    
    zoom_factor[0] = selfp->current_scale_x;
    zoom_factor[1] = selfp->current_scale_y;
    
    for (zoom_idx = 0; zoom_idx < 2; zoom_idx++)
      {
        double z = zoom_factor[zoom_idx];  /* A shortcut */
        if (selfp->do_linear_zoom_steps) {
          if (z < 0.5)
            z = 1.0 / (1.0/z-1);
          else
            z = z+1;
        }
        else 
          z *= factor;
        zoom_factor[zoom_idx] = z;
      }
    
    if (x<0)
      x = selfp->canvas_width/2;
    if (y<0)
      y = selfp->canvas_height/2;
    
    gtk_image_viewer_zoom_around_fixed_point(self,
                                             zoom_factor[0],
                                             zoom_factor[1],
                                             x, y,
                                             selfp->canvas_width/2,
                                             selfp->canvas_height/2);
    
    return 1;
  }

  public gint
  zoom_out(self, int x, int y, double factor)
  {
    double zoom_factor[2];
    int zoom_idx;
    
    if (factor<0)
      factor = 1.1; 
    
    zoom_factor[0] = selfp->current_scale_x;
    zoom_factor[1] = selfp->current_scale_y;
    
    for (zoom_idx = 0; zoom_idx < 2; zoom_idx++)
      {
        double z = zoom_factor[zoom_idx];  /* A shortcut */
        if (selfp->do_linear_zoom_steps) {
          if (z <= 1.0)
            z = 1.0 / (1.0/z+1);
          else
            z = z-1;
        }
        else 
          z /= factor;
        zoom_factor[zoom_idx] = z;
      }
    
    gtk_image_viewer_zoom_around_fixed_point(self,
                                             zoom_factor[0],
                                             zoom_factor[1],
                                             selfp->canvas_width/2,
                                             selfp->canvas_height/2,
                                             selfp->canvas_width/2,
                                             selfp->canvas_height/2);
    return 1;
  }

  public
  gint zoom_to_box(self,
                   double world_min_x,
                   double world_min_y,
                   double world_max_x,
                   double world_max_y,
                   double pixel_margin,
                   gboolean preserve_aspect)
  {
      double w = selfp->canvas_width;
      double h = selfp->canvas_height;
#if 0
      printf("alloc_width=%f alloc_height=%f\n",
             w,h);
#endif
      double new_scale_x = (w-2*pixel_margin)/(world_max_x-world_min_x);
      double new_scale_y = (h-2*pixel_margin)/(world_max_y-world_min_y);
      
      if (preserve_aspect) {
          if (new_scale_x > new_scale_y)
              new_scale_x = new_scale_y;
          else
              new_scale_y = new_scale_x;
      }
      // This works for both flip and not flip!
      double new_x0 = new_scale_x*0.5*(world_max_x+world_min_x)-w/2;
      double new_y0 = new_scale_y*0.5*(world_max_y+world_min_y)-h/2;

      view_changed(self, FALSE, new_scale_x, new_scale_y, new_x0, new_y0);
      
      return 0;
  }
                   
  /**
   * gtk_image_viewer_set_hadjustment:
   * @image_viewer: a #GtkImage_Viewer.
   * @adjustment: a #GtkAdjustment.
   * 
   * Sets the horizontal adjustment of the image_viewer.
   **/
  public void
  set_hadjustment (self,
                   GtkAdjustment *adjustment)
  {
    g_return_if_fail (GTK_IS_IMAGE_VIEWER (self));
    if (adjustment) {
        g_return_if_fail (GTK_IS_ADJUSTMENT (adjustment));
    }
  
    if (selfp->hadjustment && selfp->hadjustment != adjustment)
      {
        gtk_signal_disconnect_by_data (GTK_OBJECT (selfp->hadjustment), self);
        gtk_object_unref (GTK_OBJECT (selfp->hadjustment));
        selfp->hadjustment = NULL;
      }
  
    if (!adjustment)
      adjustment = GTK_ADJUSTMENT (gtk_adjustment_new (0.0, 0.0, 0.0,
  						     0.0, 0.0, 0.0));
  
    if (selfp->hadjustment != adjustment)
      {
        selfp->hadjustment = adjustment;
        gtk_object_ref (GTK_OBJECT (selfp->hadjustment));
        gtk_object_sink (GTK_OBJECT (selfp->hadjustment));
        
        gtk_signal_connect (GTK_OBJECT (adjustment), "value_changed",
  			  G_CALLBACK(hadjustment_value_changed),
  			  (gpointer) self);
      }
  
    //    g_object_notify (G_OBJECT (self), "hadjustment");
  }
  
  /**
   * gtk_image_viewer_set_vadjustment:
   * @image_viewer: a #GtkImage_Viewer.
   * @adjustment: a #GtkAdjustment.
   * 
   * Sets the vertical adjustment of the image_viewer.
   **/
  public
  void
  set_vadjustment (self,
                   GtkAdjustment *adjustment)
  {
    g_return_if_fail (GTK_IS_IMAGE_VIEWER (self));
    if (adjustment) {
        g_return_if_fail (GTK_IS_ADJUSTMENT (adjustment));
    }
  
    if (selfp->vadjustment && selfp->vadjustment != adjustment)
      {
        gtk_signal_disconnect_by_data (GTK_OBJECT (selfp->vadjustment), self);
        gtk_object_unref (GTK_OBJECT (selfp->vadjustment));
        selfp->vadjustment = NULL;
      }
  
    if (!adjustment)
      adjustment = GTK_ADJUSTMENT (gtk_adjustment_new (0.0, 0.0, 0.0,
  						     0.0, 0.0, 0.0));
  
    if (selfp->vadjustment != adjustment)
      {
        selfp->vadjustment = adjustment;
        gtk_object_ref (GTK_OBJECT (selfp->vadjustment));
        gtk_object_sink (GTK_OBJECT (selfp->vadjustment));
        
        gtk_signal_connect (GTK_OBJECT (adjustment), "value_changed",
  			  G_CALLBACK(vadjustment_value_changed),
  			  (gpointer) self);
      }
  
    // g_object_notify (G_OBJECT (self), "vadjustment");
    update_adjustments(self);
  }

  public
  void
  set_image(self,
            GdkPixbuf *image)
  {
    if (selfp->image)
      gdk_pixbuf_unref(selfp->image);
    selfp->image = image;

    if (image)
      {
        gdk_pixbuf_ref(image);
        selfp->scroll_min_x = 0;
        selfp->scroll_min_y = 0;
        selfp->scroll_width = gdk_pixbuf_get_width(image);
        selfp->scroll_height = gdk_pixbuf_get_height(image);
        selfp->scroll_max_x = selfp->scroll_width;
        selfp->scroll_max_y = selfp->scroll_height;
      }

    gtk_image_viewer_redraw(self, TRUE);
  }

  public
  const GdkPixbuf *
  get_image(self)
  {
    return selfp->image;
  }

  signal last BOOL (OBJECT, OBJECT)
  gboolean
  set_scroll_adjustments (self,
                          Gtk:Adjustment    *hadjustment,
                          Gtk:Adjustment    *vadjustment)
  {
    if (selfp->hadjustment != hadjustment)
      gtk_image_viewer_set_hadjustment (self, hadjustment);
    if (selfp->vadjustment != vadjustment)
      gtk_image_viewer_set_vadjustment (self, vadjustment);
    return TRUE;
  }

  signal last NONE (POINTER, INT, INT, DOUBLE, DOUBLE)
  void
  image_annotate(self,
                 GdkPixbuf *pixbuf,
                 gint shift_x, gint shift_y,
                 gdouble scale_x, gdouble scale_y);

  signal last NONE (INT, INT)
  void
  flip_changed(self,
               gboolean horizontal_flip,
               gboolean vertical_flip);

  public
  guint
  get_image_width(GtkImageViewer *self)
  { 
    return gdk_pixbuf_get_width (selfp->image);
  }
  
  public guint
  get_image_height(GtkImageViewer *self)
  { 
    return gdk_pixbuf_get_height (selfp->image);
  }

  public void
  canv_coord_to_img_coord(self,
                          double cx, double cy,
                          // output
                          double* imgx, double* imgy)
  {
    if (selfp->do_flip_horizontal) {
        int w = selfp->canvas_width;
        *imgx = (selfp->current_x0+w-cx)/selfp->current_scale_x;
    }
    else
      *imgx=(selfp->current_x0+cx)/selfp->current_scale_x;

    if (selfp->do_flip_vertical) {
        int h = selfp->canvas_height;
        *imgy = (selfp->current_y0+h-cy)/selfp->current_scale_y;
    }
    else
      *imgy=(selfp->current_y0+cy)/selfp->current_scale_y;

#if 0
    if (selfp->do_flip_vertical)
      *imgy = -(cy-selfp->current_y0-GTK_WIDGET(self)->allocation.height)/selfp->current_scale_y;
    else
      *imgy=(cy+selfp->current_y0)/selfp->current_scale_y;
#endif
  }

  public void
  img_coord_to_canv_coord(self,
                          double imgx, double imgy,
                          // output
                          double* canvx, double* canvy)
  {
    if (selfp->do_flip_horizontal) {
        int w = selfp->canvas_width;
        *canvx = (selfp->current_x0+w-imgx*selfp->current_scale_x);
    }
    else
      *canvx = imgx*selfp->current_scale_x-selfp->current_x0;
    
    
    if (selfp->do_flip_vertical) {
        int h = selfp->canvas_height;
        *canvy = (selfp->current_y0+h-imgy*selfp->current_scale_y);
    }
    else
      *canvy = imgy*selfp->current_scale_y-selfp->current_y0;
  }

  public void
  set_zoom_range(self,
                 double min_zoom,
                 double max_zoom)
  {
      selfp->min_zoom = min_zoom;
      selfp->max_zoom = max_zoom;
  }

  public void
  get_scale_and_shift(self,
                      gdouble *scale_x,
                      gdouble *scale_y,
                      gint *shift_x,
                      gint *shift_y)
  {
    *scale_x = selfp->current_scale_x;
    *scale_y = selfp->current_scale_y;
    *shift_x = selfp->current_x0;
    *shift_y = selfp->current_y0;
    if (selfp->do_flip_horizontal) {
        int cnv_w = selfp->canvas_width;
        *scale_x = -*scale_x;
        *shift_x += cnv_w;
        *shift_x = -*shift_x;
    }
    if (selfp->do_flip_vertical) {
        int cnv_h = selfp->canvas_height;
        *scale_y = -*scale_y;
        *shift_y += cnv_h;
        *shift_y = -*shift_y;
    }
  }

  public void
  set_scale_and_shift(self,
                      gdouble scale_x,
                      gdouble scale_y,
                      gint shift_x,
                      gint shift_y)
  {
    if (selfp->do_flip_horizontal) {
        int cnv_w = selfp->canvas_width;
        scale_x = -scale_x;
        shift_x = cnv_w-shift_x;
    }
    if (selfp->do_flip_vertical) {
        int cnv_h = selfp->canvas_height;
        scale_y = -scale_y;
        shift_y = cnv_h-shift_y;
    }
    if (selfp->current_scale_x != scale_x
        || selfp->current_scale_y != scale_y
        || selfp->current_x0 != shift_x
        || selfp->current_y0 != shift_y) {
        selfp->current_scale_x = scale_x;
        selfp->current_scale_y = scale_y;
        selfp->current_x0 = shift_x;
        selfp->current_y0 = shift_y;
        
        gtk_image_viewer_redraw(self, TRUE);
    }
  }
    
  public void
  set_transfer_map(self,
                   guint8 *rmap,
                   guint8 *gmap,
                   guint8 *bmap)
  {
  }

  public void
  set_fill_on_resize(self,
                     gboolean whether)
  {
      selfp->do_fill_on_resize = whether;
  }

  public void
  one_shot_block_fill_on_resize(self)
  {
      selfp->one_shot_block_fill_on_resize = TRUE;
  }

  public gboolean
  get_fill_on_resize(self)
  {
      return selfp->do_fill_on_resize;
  }

  public void
  set_scroll_region(self,
                    double x0, double y0,
                    double x1, double y1)
  {
    selfp->scroll_min_x = x0;
    selfp->scroll_max_x = x1;
    selfp->scroll_min_y = y0;
    selfp->scroll_max_y = y1;
    selfp->scroll_width = x1-x0;
    selfp->scroll_height = y1-y0;

    update_adjustments(self);
  }

  public void
  set_flip(self,
           gboolean do_flip_horizontal,
           gboolean do_flip_vertical)
  {
    gboolean need_signal=FALSE;

    // If we have no adjustments then create them as they are the only
    // message channel to transfer flip info
    if (!selfp->hadjustment || !selfp->vadjustment)
      {
        gtk_image_viewer_set_hadjustment (self, NULL);
        gtk_image_viewer_set_vadjustment (self, NULL);
        update_adjustments(self);
      }

    // Flip adjustments
    if (selfp->hadjustment && do_flip_horizontal != selfp->do_flip_horizontal) {
      selfp->hadjustment->value = 1 - selfp->hadjustment->page_size - selfp->hadjustment->value;
      selfp->do_flip_horizontal = do_flip_horizontal;
      gtk_adjustment_value_changed(selfp->hadjustment);
      need_signal = TRUE;
    }
    if (selfp->vadjustment && do_flip_vertical != selfp->do_flip_vertical) {
      selfp->vadjustment->value = 1 - selfp->vadjustment->page_size - selfp->vadjustment->value;
      selfp->do_flip_vertical = do_flip_vertical;
      gtk_adjustment_value_changed(selfp->vadjustment);
      need_signal =TRUE;
    }

    if (need_signal)
      {
        // Emit flip signal
        {
          GValue ___param_values[3];
          GValue ___return_val;
          int i;
          
          memset (&___return_val, 0, sizeof (___return_val));
          memset (&___param_values, 0, sizeof (___param_values));
          
          ___param_values[0].g_type = 0;
          g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
          g_value_set_instance (&___param_values[0], (gpointer) self);
          
          ___param_values[1].g_type = 0;
          g_value_init (&___param_values[1], G_TYPE_INT);
          g_value_set_int (&___param_values[1], selfp->do_flip_horizontal);
          
          ___param_values[2].g_type = 0;
          g_value_init (&___param_values[2], G_TYPE_INT);
          g_value_set_int (&___param_values[2], selfp->do_flip_vertical);
          
          g_signal_emitv (___param_values,
                          object_signals[FLIP_CHANGED_SIGNAL],
                          0 /* detail */,
                          &___return_val);
          
          for (i=0; i<3; i++)
            g_value_unset (&___param_values[i]);
          
          gtk_image_viewer_redraw(self, TRUE);
        }
      }
  }

  public void
  zoom_reset(self)
  {
      zoom_reset(self);
  }

  public void
  zoom_fit(self)
  {
    gtk_image_viewer_zoom_to_box(self,
                                 selfp->scroll_min_x,
                                 selfp->scroll_min_y,
                                 selfp->scroll_max_x,
                                 selfp->scroll_max_y,
                                 0,
                                 TRUE);
  }
}
  
%{
/*======================================================================
//  view_changed does clipping, scrolling and scaling.
//----------------------------------------------------------------------
*/
static gint
view_changed(GtkImageViewer *self,
	     int do_force,
	     double scale_x, double scale_y, double x0, double y0)
{
  GtkWidget *widget = GTK_WIDGET(self);
  GdkPixbuf *im;
  int render_width, render_height;
  GdkRectangle expose_rect;
  //printf("view_changed\n");
  if (!widget || !widget->window)
    return 0;

  g_return_val_if_fail (self != NULL, FALSE);
  g_return_val_if_fail (GTK_IS_IMAGE_VIEWER (self), FALSE);

  widget = GTK_WIDGET(self);

  im = selfp->image; /* A short cut */

  DBG2(g_print("force sx sy x0 y0 = %d %f %f %f %f\n",
	       do_force, scale_x, scale_y, x0, y0));

  /* This should certainly be configurable */
  if (scale_x < 1.0)
    selfp->interp_type = GDK_INTERP_BILINEAR;
  else
    selfp->interp_type = GDK_INTERP_NEAREST;

  /* Clip the scale */
  if (selfp->max_zoom > 0 && scale_x>selfp->max_zoom && scale_y > selfp->max_zoom)
    return 0;
  else if (selfp->min_zoom > 0 && scale_x < selfp->min_zoom && scale_y < selfp->min_zoom)
    return 0;

  /* Clip the request */
  if (im
      || (selfp->scroll_width > 0 && selfp->scroll_height > 0)
      ) {
        int cwidth = selfp->canvas_width;
        int cheight = selfp->canvas_height;
        double height, width;
        
        width = selfp->scroll_width;
        height = selfp->scroll_height;
        
        if (im && width*scale_x > cwidth)
            render_width = cwidth;
        else
            render_width = (int)(width * scale_x);
        
        if (im && height*scale_y > cheight)
            render_height = cheight;
        else
            render_height = (int)(height * scale_y);
        
        // Clip only for images
        if (im) {
            if (render_width < cwidth)
                x0 = -(cwidth - render_width)/2;
            else if (x0 + render_width > width*scale_x)
                x0 = width*scale_x - render_width;
            else if (x0<0)
                x0 = 0;
            
            if (im && render_height < cheight)
                y0 = -(cheight - render_height)/2;
            else if (y0 + render_height > height*scale_y)
                y0 = height*scale_y - render_height;
            else if (y0<0)
                y0 = 0;
        }
  }
  
  /* If scale is the same, then the image has only been scrolled,
     and we only need to update the exposed areas.
   */
  if (!do_force
      && widget->window
      && scale_x == selfp->current_scale_x
      && scale_y == selfp->current_scale_y
      )
    {
      int dx = (int)(x0 - selfp->current_x0);
      int dy = (int)(y0 - selfp->current_y0);

      // Scroll in opposite direction if we are flipping
      if (selfp->do_flip_horizontal)
        dx = -dx;
      if (selfp->do_flip_vertical)
        dy = -dy;
      int src_x = (dx < 0) ? 0 : dx;
      int src_y = (dy < 0) ? 0 : dy;
      int dst_x = (dx < 0) ? -dx : 0;
      int dst_y = (dy < 0) ? -dy : 0;

      /* Construct the gc the first time it is used */
      if (!selfp->gc)
        {
	  selfp->gc = gdk_gc_new(widget->window);
	  gdk_gc_copy(selfp->gc, widget->style->white_gc);
	  gdk_gc_set_exposures(selfp->gc, TRUE);
	}

      selfp->current_x0 = (int)x0;
#if 0
      printf("view changed current_x0 dx y0 dy= %d %d %d %d\n",
             selfp->current_x0, dx,
             selfp->current_y0, dy
             );
#endif
      selfp->current_y0 = (int)y0;

      /* Scroll visible region */
      gdk_draw_drawable (widget->window,
                         selfp->gc,
                         widget->window,
                         src_x, src_y,
                         dst_x, dst_y,
                         GTK_WIDGET(self)->allocation.width - abs (dx),
                         GTK_WIDGET(self)->allocation.height - abs (dy));

      DBG2(g_print("Filling in: dx dy = %d %d\n", dx, dy));
      /* And fill in the new areas */
      if (dx)
	{
	    expose_rect.x = (dx < 0) ? 0 : GTK_WIDGET(self)->allocation.width - dx;
	    expose_rect.y = 0;
	    expose_rect.width = abs(dx);
	    expose_rect.height = GTK_WIDGET(self)->allocation.height;

	    gdk_window_invalidate_rect(widget->window,
				       &expose_rect,
				       FALSE);
	    gdk_window_process_updates(widget->window,
				       FALSE);

	}
      if (dy)
	{
	    expose_rect.x = 0;
	    expose_rect.y = (dy < 0) ? 0 : GTK_WIDGET(self)->allocation.height - dy;;
	    expose_rect.width = GTK_WIDGET(self)->allocation.width;
	    expose_rect.height = abs(dy);

	    gdk_window_invalidate_rect(widget->window,
				       &expose_rect,
				       FALSE);
	    gdk_window_process_updates(widget->window,
				       FALSE);

	}
    }
  
  else if (widget->window &&
	   (do_force
      || scale_x != selfp->current_scale_x
      || scale_y != selfp->current_scale_y
      || x0 != selfp->current_x0
      || y0 != selfp->current_y0))
    {
      /* Remember the current transform */
      selfp->current_scale_x = scale_x;
      selfp->current_scale_y = scale_y;
      selfp->current_x0 = (gint)x0;
      selfp->current_y0 = (gint)y0;

      expose_rect.x = 0;
      expose_rect.y = 0;
      expose_rect.width = GTK_WIDGET(self)->allocation.width;
      expose_rect.height = GTK_WIDGET(self)->allocation.height;

      /* gdk_window_ref (expose_event.window); */
      gdk_window_invalidate_rect(widget->window,
				 &expose_rect,
				 TRUE);
      gdk_window_process_updates(widget->window,
				 TRUE
				 );
    }

  return 1;
}

/*======================================================================
//  Zoom related functions.
//----------------------------------------------------------------------*/
static gint
zoom_reset(GtkImageViewer *self)
{
    view_changed(self, TRUE, 1, 1, 0, 0);
    return 1;
}

static gint
zoom_translate(GtkImageViewer *self, int dx, int dy)
{
  view_changed(self,
	       FALSE,
	       selfp->current_scale_x,
	       selfp->current_scale_y,
	       selfp->current_x0+dx,
	       selfp->current_y0+dy);
  return 1;
}


static void
hadjustment_value_changed (GtkAdjustment *hadjustment,
                           gpointer       data)
{
  GtkImageViewer *self;
  double min = 0;
  double new_x0, dx;
  double width;

  g_return_if_fail (GTK_IS_ADJUSTMENT (hadjustment));
  g_return_if_fail (GTK_IS_IMAGE_VIEWER (data));

  self = GTK_IMAGE_VIEWER (data);

  width = selfp->scroll_width;
  min = selfp->scroll_min_x;

  // if flip then flip back to calculate same x0 as before flip!
  double v = hadjustment->value;
  double s = selfp->current_scale_x;
  if (selfp->do_flip_horizontal)
    v = 1.0 - hadjustment->page_size - v;
  new_x0 = (v * (width-selfp->hadjustment->page_size) + min) * s;
  dx = new_x0 - selfp->current_x0;

  DBG(printf("hadjustment_value_changed: dx = %d\n", (int)dx));
  if ((int)dx!=0) {
    zoom_translate(self, (int)dx, 0);
  }
    
}

static void
vadjustment_value_changed (GtkAdjustment *vadjustment,
                           gpointer       data)
{
  GtkImageViewer *self;
  double min = 0;
  double new_y0, dy;
  double height;

  g_return_if_fail (GTK_IS_ADJUSTMENT (vadjustment));
  g_return_if_fail (GTK_IS_IMAGE_VIEWER (data));

  self = GTK_IMAGE_VIEWER (data);

  height = selfp->scroll_height;
  min = selfp->scroll_min_y;

  // if flip then flip back to calculate same x0 as before flip!
  double v = vadjustment->value;
  double s = selfp->current_scale_y;
  if (selfp->do_flip_vertical)
      v = 1.0 - vadjustment->page_size - v;
  new_y0 = (v * (height-selfp->vadjustment->page_size) + min) * s;
  dy = new_y0 - selfp->current_y0;

  if ((int)dy!=0) {
#if 0
    printf("vadjustment: value dy = %f %d\n", vadjustment->value, (int)dy);
#endif
    zoom_translate(self, 0, (int)dy);
  }
}

// This function should update the adjustment so that they reflect
// the scrolling of the widget as it was decided somewhere else.
static gboolean update_adjustments(GtkImageViewer *self)
{
  double scroll_min_x = 0, scroll_min_y = 0, scroll_max_x=0, scroll_max_y=0;
  double scroll_width=0, scroll_height=0;
  double width, height;

  if (!selfp->hadjustment
      || !selfp->vadjustment
      )
    return 0;

  width = selfp->scroll_width;
  height = selfp->scroll_height;

  // Don't rely on scroll_min_x, etc for calculation of adjustments
  // as these may have been overridden because of aspect ratio
  // considerations. Recalculate them.
  gtk_image_viewer_img_coord_to_canv_coord(self,
                                           0,0,
                                           // output
                                           &scroll_min_x, &scroll_min_y);
  gtk_image_viewer_img_coord_to_canv_coord(self,
                                           selfp->canvas_width+1,selfp->canvas_height+1,
                                           // output
                                           &scroll_max_x, &scroll_max_y);
  scroll_width = scroll_max_x - scroll_min_x;
  scroll_height = scroll_max_y - scroll_min_y;

  if (selfp->hadjustment)
    {
      selfp->hadjustment->lower = 0;
      selfp->hadjustment->upper = 1.0;
      selfp->hadjustment->step_increment = 0.01;
      selfp->hadjustment->page_size = selfp->canvas_width / (selfp->scroll_width * selfp->current_scale_x);
      
      double v = (selfp->current_x0/selfp->current_scale_x - selfp->scroll_min_x)
        /(selfp->scroll_width-selfp->hadjustment->page_size);
      if (selfp->do_flip_horizontal)
        selfp->hadjustment->value = 1.0 - selfp->hadjustment->page_size -v;
      else
        selfp-> hadjustment->value = v;

      DBG(printf("current_x0 scale ps val = %d %f %f %f\n",
             selfp->current_x0,
             selfp->current_scale_x,
             selfp->hadjustment->page_size,
                 selfp->hadjustment->value));

      gtk_adjustment_changed(selfp->hadjustment);
      gtk_adjustment_value_changed(selfp->hadjustment);

    }

  if (selfp->vadjustment)
    {
      selfp->vadjustment->lower = 0;
      selfp->vadjustment->upper = 1.0;
      selfp->vadjustment->step_increment = 0.01;
      DBG(printf("canvas_height sh sy scroll_height*current_scale_y = %d %f %f %f\n",
                 selfp->canvas_height,
                 selfp->scroll_height,
                 selfp->current_scale_y,
                 selfp->scroll_height * selfp->current_scale_y));
      selfp->vadjustment->page_size = selfp->canvas_height / (selfp->scroll_height * selfp->current_scale_y);

      double v = (selfp->current_y0/selfp->current_scale_y - selfp->scroll_min_y)
        /(selfp->scroll_height-selfp->vadjustment->page_size);
      if (selfp->do_flip_vertical)
        selfp->vadjustment->value = 1.0 - selfp->vadjustment->page_size -v;
      else
        selfp->vadjustment->value = v;

      DBG(printf("vadjust: current_y0 scale ps val = %d %f %f %f\n",
                 selfp->current_y0,
                 selfp->current_scale_y,
                 selfp->vadjustment->page_size,
                 selfp->vadjustment->value));

      gtk_adjustment_changed(selfp->vadjustment);
      gtk_adjustment_value_changed(selfp->vadjustment);
    }
  return 0;
}

#if 0
  property OBJECT vadjustment
    (nick = "Vertical adjustment",
     blurb = "Vertical adjustment")
        set { selfp->vadjustment = GTK_ADJUSTMENT(g_value_dup_object (VAL)); }
        get { g_value_set_object (VAL, selfp->vadjustment); }
    ;
  property OBJECT hadjustment
    (nick = "Horizontal adjustment",
     blurb = "Horizontal adjustment")
        set { selfp->hadjustment = GTK_ADJUSTMENT(g_value_dup_object (VAL)); }
        get { g_value_set_object (VAL, selfp->hadjustment); }
    ;

#endif

%}

name: MacOS build

on:
  push:
    branches: [ "main", "v1-branch", "Kimrova-bachelorRelease" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build:

    runs-on: macos-latest

    steps:
    - uses: actions/checkout@v4
    - name: Install libtiff
      run: brew install -v libtiff
    - name: Install libjpeg-turbo
      run: brew install -v libjpeg-turbo
    - name: Install libzip
      run: brew install -v libzip
    - name: List libzip
      run: brew list libzip
    - name: Install libgsl
      run: brew install -v gsl
    - name: Install libraw
      run: brew install -v libraw
    - name: Install little-cms2
      run: brew install -v little-cms2
    - name: Install libomp
      run: brew install -v libomp
    - name: Install gtk+
      run: brew install -v gtk+
    - name: Install fftw
      run: brew install -v fftw
    - name: Install qt6
      run: brew install -v qt6
    - name: Install exiv2
      run: brew install -v exiv2
    - name: Install adwaita-icon-theme
      run: brew install -v adwaita-icon-theme
    - name: Link qt6
      run: brew link qt6 --force

    - name: Install dynlibbundler
      run: brew install -v dylibbundler
    - name: Bulid libzip
      run: |
        #wget https://libzip.org/download/libzip-1.10.1.tar.xz
        #tar xJvf libzip-1.10.1.tar.xz
        #cd libzip-*
        #cmake -DBUILD_SHARED_LIBS=OFF
        #make
        #find . -name libzip*.a
    - name: configure
      run: |
        export PATH="/opt/homebrew/opt/qt6/bin:/opt/homebrew/opt/qt/bin:$(brew --prefix qt6)/bin:$PATH"
        # Debug and find MOC explicitly
        echo "Looking for moc..."
        QT6_PREFIX=$(brew --prefix qt6)
        MOC_CANDIDATE=$(find "$QT6_PREFIX" -name "moc" -type f -perm +111 | head -n 1)
        if [ -z "$MOC_CANDIDATE" ]; then
             MOC_CANDIDATE=$(find /opt/homebrew -name "moc" -type f -perm +111 2>/dev/null | grep qt | head -n 1)
        fi
        
        if [ -n "$MOC_CANDIDATE" ]; then
          echo "Found moc at: $MOC_CANDIDATE"
          export MOC="$MOC_CANDIDATE"
          # Also add its dir to PATH
          export PATH="$(dirname "$MOC_CANDIDATE"):$PATH"
        else
          echo "WARNING: Could not find moc executable via find."
          # Fallback to pkg-config attempt
          QT6_BIN=$(pkg-config --variable=host_bins Qt6Core)
          if [ -n "$QT6_BIN" ]; then
             echo "Qt6 bin from pkg-config: $QT6_BIN"
             export PATH="$QT6_BIN:$PATH"
          fi
        fi
        
        echo "Final PATH=$PATH"
        echo "MOC=$MOC"

        CXXFLAGS="-Ofast -flto -I/opt/homebrew/include -I/opt/homebrew/opt/libomp/include -Xclang=-fopenmp" LDFLAGS=" -L/opt/homebrew/lib -L/opt/homebrew/opt/libomp/lib -lomp " CXX=clang++ CC=clang ./configure --disable-openmp --prefix=/tmp/Color-Screen-MacOS  --enable-qtgui --disable-static-link  MOC="$MOC"
    - name: Upload config.log
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: config.log
        path: |
          config.log
    - name: make
      run: make
    - name: make check
      run: make check
    - name: Upload Test Results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: testsuite
        path: |
          testsuite/*.txt
          testsuite/*.log
          testsuite/*.par
    - name: make install-strip
      run: make install-strip
    - name: tar
      run: cd /tmp ; tar czvf /tmp/Color-Screen-MacOS.tar.gz Color-Screen-MacOS/
    - uses: actions/upload-artifact@v4
      with:
        name: macOS-binary
        path: /tmp/Color-Screen-MacOS.tar.gz
    - name: Install imagemagick
      run: brew install -v imagemagick

    - name: Package App Bundle
      run: |
        # Create App Structure
        mkdir -p Color-Screen.app/Contents/MacOS
        mkdir -p Color-Screen.app/Contents/Resources
        
        # Copy Binaries
        cp /tmp/Color-Screen-MacOS/bin/colorscreen-qt Color-Screen.app/Contents/MacOS/Color-Screen
        cp /tmp/Color-Screen-MacOS/bin/colorscreen Color-Screen.app/Contents/MacOS/
        
        # Create Info.plist
        cat > Color-Screen.app/Contents/Info.plist <<EOF
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>CFBundleExecutable</key>
            <string>Color-Screen</string>
            <key>CFBundleIconFile</key>
            <string>icon.icns</string>
            <key>CFBundleIdentifier</key>
            <string>com.janhubicka.colorscreen</string>
            <key>CFBundlePackageType</key>
            <string>APPL</string>
            <key>CFBundleSignature</key>
            <string>????</string>
            <key>LSMinimumSystemVersion</key>
            <string>10.13</string>
            <key>NSHighResolutionCapable</key>
            <true/>
        </dict>
        </plist>
        EOF
        
        # Generate Icon
        mkdir icon.iconset
        magick -background none images/icon.svg -resize 16x16     icon.iconset/icon_16x16.png
        magick -background none images/icon.svg -resize 32x32     icon.iconset/icon_16x16@2x.png
        magick -background none images/icon.svg -resize 32x32     icon.iconset/icon_32x32.png
        magick -background none images/icon.svg -resize 64x64     icon.iconset/icon_32x32@2x.png
        magick -background none images/icon.svg -resize 128x128   icon.iconset/icon_128x128.png
        magick -background none images/icon.svg -resize 256x256   icon.iconset/icon_128x128@2x.png
        magick -background none images/icon.svg -resize 512x512   icon.iconset/icon_512x512.png
        magick -background none images/icon.svg -resize 1024x1024 icon.iconset/icon_512x512@2x.png
        iconutil -c icns icon.iconset
        cp icon.icns Color-Screen.app/Contents/Resources/
        
        # Run macdeployqt
        $(brew --prefix qt6)/bin/macdeployqt Color-Screen.app -verbose=2 -always-overwrite
        
        # Copy libcolorscreen
        cp /tmp/Color-Screen-MacOS/lib/libcolorscreen.*.dylib Color-Screen.app/Contents/Frameworks/
        
        # Fix libcolorscreen ID
        for LIB in Color-Screen.app/Contents/Frameworks/libcolorscreen.*.dylib; do
             NAME=$(basename "$LIB")
             install_name_tool -id "@executable_path/../Frameworks/$NAME" "$LIB"
        done
        
        # Fix libcolorscreen reference in executables
        # We find the exact path embedded in the binary to replace it reliably
        for EXECUTABLE in Color-Screen.app/Contents/MacOS/Color-Screen Color-Screen.app/Contents/MacOS/colorscreen; do
            echo "Fixing libcolorscreen for $EXECUTABLE..."
            # Find the line containing libcolorscreen
            LIBSCREEN_PATH=$(otool -L "$EXECUTABLE" | grep "libcolorscreen" | awk '{print $1}')
            if [ -n "$LIBSCREEN_PATH" ]; then
                echo "  Found reference: $LIBSCREEN_PATH"
                install_name_tool -change "$LIBSCREEN_PATH" "@executable_path/../Frameworks/libcolorscreen.2.dylib" "$EXECUTABLE"
            else
                echo "  WARNING: libcolorscreen reference not found in $EXECUTABLE"
            fi
        done

        # Manually copy missing dylibs (similar to Windows)
        # Assuming brew installs are in standard locations
        cp /opt/homebrew/lib/libgsl.*.dylib Color-Screen.app/Contents/Frameworks/ || true
        cp /opt/homebrew/lib/libgslcblas.*.dylib Color-Screen.app/Contents/Frameworks/ || true
        cp /opt/homebrew/lib/libtiff.*.dylib Color-Screen.app/Contents/Frameworks/ || true
        cp /opt/homebrew/lib/libjpeg.*.dylib Color-Screen.app/Contents/Frameworks/ || true
        cp /opt/homebrew/lib/liblcms2.*.dylib Color-Screen.app/Contents/Frameworks/ || true
        cp /opt/homebrew/lib/libraw.*.dylib Color-Screen.app/Contents/Frameworks/ || true
        cp /opt/homebrew/lib/libfftw3.*.dylib Color-Screen.app/Contents/Frameworks/ || true
        cp /opt/homebrew/lib/libomp.dylib Color-Screen.app/Contents/Frameworks/ || true
        cp /opt/homebrew/lib/libzip.*.dylib Color-Screen.app/Contents/Frameworks/ || true
        cp /opt/homebrew/lib/libexiv2.*.dylib Color-Screen.app/Contents/Frameworks/ || true
        cp /opt/homebrew/lib/libexpat.*.dylib Color-Screen.app/Contents/Frameworks/ || true
        
        # Fix RPATHs for manually copied libs
        for LIB in Color-Screen.app/Contents/Frameworks/*.dylib; do
            NAME=$(basename "$LIB")
            install_name_tool -id "@executable_path/../Frameworks/$NAME" "$LIB"
        done
        
        # Fix dependencies WITHIN the bundled frameworks (dylib -> dylib references)
        # e.g. libgsl linking against libgslcblas or libcolorscreen linking against libgsl
        # This is CRITICAL because the system libs will be uninstalled
        for DYLIB in Color-Screen.app/Contents/Frameworks/*.dylib; do
             [ -f "$DYLIB" ] || continue
             echo "Fixing inner dependencies for $(basename "$DYLIB")..."
             
             # Use otool to find dependencies in homebrew prefix
             # We use process substitution to grep cleanly
             # We grep for /opt/homebrew/ to catch both /lib/ and /opt/ (keg-only) paths
             otool -L "$DYLIB" | grep '/opt/homebrew/' | awk '{print $1}' | while read -r DEP_PATH; do
                 DEP_NAME=$(basename "$DEP_PATH")
                 
                 # Check if we have bundled this dependency
                 if [ -f "Color-Screen.app/Contents/Frameworks/$DEP_NAME" ]; then
                      echo "  Rewriting $DEP_NAME in $(basename "$DYLIB")..."
                      # Use @loader_path because these are sibling libraries in the same directory
                      install_name_tool -change "$DEP_PATH" "@loader_path/$DEP_NAME" "$DYLIB"
                 else
                      echo "  Warning: Inner dependency $DEP_NAME needed by $(basename "$DYLIB") not found in bundle!"
                 fi
             done
        done

        # Bundle Adwaita icons (if available)
        # Bundle Adwaita icons (if available)
        mkdir -p Color-Screen.app/Contents/share/icons
        ADWAITA_PREFIX=$(brew --prefix adwaita-icon-theme)
        if [ -d "$ADWAITA_PREFIX/share/icons/Adwaita" ]; then
             echo "Copying Adwaita icons from $ADWAITA_PREFIX/share/icons/Adwaita"
             cp -r "$ADWAITA_PREFIX/share/icons/Adwaita" Color-Screen.app/Contents/share/icons/ || true
        elif [ -d "/opt/homebrew/share/icons/Adwaita" ]; then
             cp -r /opt/homebrew/share/icons/Adwaita Color-Screen.app/Contents/share/icons/ || true
        elif [ -d "/usr/local/share/icons/Adwaita" ]; then
             cp -r /usr/local/share/icons/Adwaita Color-Screen.app/Contents/share/icons/ || true
        fi

        # Comprehensively fix library references for BOTH executables
        # This ensures both GUI and CLI are fully self-contained
        for EXECUTABLE in Color-Screen.app/Contents/MacOS/Color-Screen Color-Screen.app/Contents/MacOS/colorscreen; do
            echo "Fixing dependencies for $EXECUTABLE..."
            
            # Discover all dependencies pointing to /opt/homebrew/
            # Use process substitution to avoid subshell issues
            while IFS= read -r DYLIB_PATH; do
                DYLIB_NAME=$(basename "$DYLIB_PATH")
                
                # Check if we have this library bundled
                if [ -f "Color-Screen.app/Contents/Frameworks/$DYLIB_NAME" ]; then
                    echo "  Rewriting $DYLIB_NAME..."
                    install_name_tool -change "$DYLIB_PATH" "@executable_path/../Frameworks/$DYLIB_NAME" "$EXECUTABLE"
                else
                    echo "  Warning: $DYLIB_NAME not found in Frameworks/"
                fi
            done < <(otool -L "$EXECUTABLE" | grep '/opt/homebrew/' | awk '{print $1}')
        done
        
        # Deep Code Sign (Ad-Hoc)
        codesign --deep --force --verify --verbose --sign "-" Color-Screen.app
        

        
        # Zip it
        ditto -c -k --keepParent Color-Screen.app Color-Screen-macOS.zip

    - uses: actions/upload-artifact@v4
      with:
        name: macdeployqt-debug
        path: macdeployqt_debug.txt

    - uses: actions/upload-artifact@v4
      with:
        name: macOS-Color-Screen-App
        path: Color-Screen-macOS.zip
    - name: make distclean
      run: make distclean
    - name: configure with checking
      run: |
        export PATH="/opt/homebrew/opt/qt6/bin:/opt/homebrew/opt/qt/bin:$(brew --prefix qt6)/bin:$PATH"
        # Debug and find MOC explicitly
        echo "Looking for moc..."
        QT6_PREFIX=$(brew --prefix qt6)
        MOC_CANDIDATE=$(find "$QT6_PREFIX" -name "moc" -type f -perm +111 | head -n 1)
        if [ -z "$MOC_CANDIDATE" ]; then
             MOC_CANDIDATE=$(find /opt/homebrew -name "moc" -type f -perm +111 2>/dev/null | grep qt | head -n 1)
        fi
        
        if [ -n "$MOC_CANDIDATE" ]; then
          echo "Found moc at: $MOC_CANDIDATE"
          export MOC="$MOC_CANDIDATE"
          export PATH="$(dirname "$MOC_CANDIDATE"):$PATH"
        else
          QT6_BIN=$(pkg-config --variable=host_bins Qt6Core)
          if [ -n "$QT6_BIN" ]; then
             export PATH="$QT6_BIN:$PATH"
          fi
        fi
        
        CXXFLAGS="-O3 -ffast-math -Wall -I/opt/homebrew/include -I/opt/homebrew/opt/libomp/include -Xclang=-fopenmp -march=native" LDFLAGS="-L/opt/homebrew/lib -L/opt/homebrew/opt/libomp/lib -lomp" CXX=clang++ CC=clang ./configure --disable-openmp --prefix=/tmp/Color-Screen-MacOS --enable-gtkgui --enable-qtgui --enable-checking --disable-static-link MOC="$MOC"
    - name: make (checking enabled)
      run: make
    - name: make check (checking enabled)
      run: make check
    - name: Upload Test Results (checking enabled)
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: testsuite-checking
        path: |
          testsuite/*.txt
          testsuite/*.log

    - name: Uninstall libgsl to break one of dependencies
      run: brew uninstall  gsl
    - name: Remove install directory
      run: rm -fr /tmp/Color-Screen-MacOS
    - name: Verify application
      run: |
        # Move the app bundle to a different location to test for hardcoded paths
        echo "Moving App Bundle to ~/Applications..."
        mkdir -p ~/Applications
        mv Color-Screen.app ~/Applications/
        
        APP_PATH="$HOME/Applications/Color-Screen.app"
        
        lldb --version
        # Use lldb in batch mode:
        # -o commands run on startup (run the app)
        # -k commands run ONLY on crash (print backtrace, then exit with error)
        # -o "exit 0" runs if the app exits normally, ensuring clean exit
        lldb --batch -o "run" -k "bt" -k "exit 1" -o "exit 0" -- "$APP_PATH/Contents/MacOS/colorscreen" --version
        
        # CLI Functionality Test
        echo "Running colorscreen autodetect with lldb..."
        lldb --batch -o "run" -k "bt" -k "exit 1" -o "exit 0" -- "$APP_PATH/Contents/MacOS/colorscreen" autodetect testsuite/dufaycolor_nikon_coolsan9000ED_4000DPI_raw.tif test.par
        
        # GUI Smoke Test (launch and quit)
        # Run with debug-qt to check plugins/icons, pass image file, AND smoke-test to auto-quit
        # Redirect output to file for artifact
        # Use absolute path for the image to avoid "File not found" dialogs blocking the app
        echo "Running Color-Screen GUI binary check with --debug-qt --smoke-test..."
        (
          sleep 13; screencapture -x shot_13s.png; ps aux | grep Color-Screen > shot_13s_ps.txt;
          sleep 5; screencapture -x shot_18s.png; ps aux | grep Color-Screen > shot_18s_ps.txt;
        ) &
        #No lldb to make startup faster
        #lldb --batch -o "run" -k "bt" -k "exit 1" -o "exit 0" -- 
        "$APP_PATH/Contents/MacOS/Color-Screen" --debug-qt --smoke-test 20000 "$(pwd)/testsuite/dufaycolor_nikon_coolsan9000ED_4000DPI_raw.tif" > gui_launch_debug.txt 2>&1 || { cat gui_launch_debug.txt; exit 1; }
        
        cat gui_launch_debug.txt

    - name: Upload GUI Launch Debug
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: gui_launch_debug
        path: gui_launch_debug.txt

    - name: Upload GUI Screenshots
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: gui_screenshots
        path: |
          shot_*.png
          shot_*.txt
